---
title: "Test"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load data and clean names 
Treat <NULL> and UNKNOWN as missing
```{r}
setwd("S:/Indiana Research & Evaluation/Matthew Hanauer/CTS_grant_docs/Otsuka/data")
#non_tn_schiz_dat = read.csv("CIN_CIL_CFL_schz_dat_9_16_20.csv", header = TRUE, na.strings = c("<NULL>", "UNKNOWN"))
### Need Client.ID, Admission.Last.Service.Date, Service.Location.County, Diagnosis.Type.Diagnosis.Description, Client.Intake.Referrals.Client.Age, Gender.Gender, Race.Type.Race.Type
non_tn_schiz_data = non_tn_schiz_dat[c("Client.ID", "Service.Date", "Service.Location.County", "Client.Diagnosis.Diagnosis.Description", "Service.Age.at.Service", "Gender.Gender", "Race.Type.Race.Type", "Organization.Master.Organization.Headquarters.State.Abbreviation", "Client.Diagnosis.Ranking.Code", "Client.Diagnosis.ICD.Code")]


names(non_tn_schiz_data) = c("client_id", "service_date", "county", "diagnosis", "age", "gender", "race", "state", "diagnosis_ranking", "ICD_code")

## Load in the TN data set
tn_schiz_dat = read.csv("CTN_schz_dat_9_16_20.csv", header= TRUE, na.strings = c("<NULL>", "UNKNOWN"))
### Add a state variable
tn_schiz_dat$state = rep("TN", dim(tn_schiz_data)[1])

tn_schiz_data = tn_schiz_dat[c("Client.ID", "Service.Date", "Service.Location.County", "Diagnosis.Type.Diagnosis.Description", "Client.Intake.Referrals.Client.Age", "Gender.Gender", "Race.Type.Race.Type", "state", "Client.Diagnosis.Diagnosis.Sort", "Diagnosis.Type.Diagnostic.Code")]

## Change ranking variable to match non-TN
names(tn_schiz_data) = c("client_id", "service_date", "county", "diagnosis", "age", "gender", "race", "state", "diagnosis_ranking", "ICD_code")
describe.factor(tn_schiz_data$diagnosis_ranking)

tn_schiz_data$diagnosis_ranking = ifelse(tn_schiz_data$diagnosis_ranking == "P", 1, ifelse(tn_schiz_data$diagnosis_ranking == "S", 2, 3))
describe.factor(tn_schiz_data$diagnosis_ranking)

# Now rbind all data
#schiz_data = rbind(non_tn_schiz_data, tn_schiz_data)
schiz_data = non_tn_schiz_data
library(prettyR)
# Check for variables outside of reasonable range
#apply(non_tn_schiz_data[,2:9], 2, function(x){describe.factor(x)})
```
Subset by 18 and older 
between  May 1, 2019 and August 2020
Don't have May 1 2019 starting at July 1 2019
```{r}
schiz_data = subset( schiz_data, age > 17 | is.na(age))
sum(is.na(schiz_data$age))
sum(schiz_data$age < 18, na.rm = TRUE)
library(lubridate)
schiz_data$service_date = ymd(schiz_data$service_date)

schiz_data = subset( schiz_data, service_date >= "2019-07-01" & service_date <= "2020-08-31")
sum( schiz_data$service_date < "2019-07-01" |  schiz_data$service_date > "2020-08-31")
dim(schiz_data)
```



For variables that have matching, change the ICD-9 to ICD-10
PSYCHOTIC DISORDER DUE TO ANOTHER MEDICAL CONDITION  WITH DELUSIONS
```{r}
library(dplyr)
schiz_data$diagnosis= recode(schiz_data$diagnosis, "UNSPECIFIED SCHIZOPHRENIA SPECTRUM AND OTHER PSYCHOTIC DISORDER"= "UNSPECIFIED PSYCHOSIS NOT DUE TO A SUBSTANCE OR KNOWN PHYSIOLOGICAL CONDITION", "PSYCHOTIC DISORDER DUE TO ANOTHER MEDICAL CONDITION  WITH DELUSIONS" = "PSYCHOTIC DISORDER WITH DELUSIONS DUE TO KNOWN PHYSIOLOGICAL CONDITION",  "PSYCHOTIC DISORDER DUE TO ANOTHER MEDICAL CONDITION  WITH HALLUCINATIONS" = "PSYCHOTIC DISORDER WITH HALLUCINATIONS DUE TO KNOWN PHYSIOLOGICAL CONDITION", "UNSPECIFIED PSYCHOSIS" = "UNSPECIFIED PSYCHOSIS NOT DUE TO A SUBSTANCE OR KNOWN PHYSIOLOGICAL CONDITION")
sum(schiz_data$diagnosis == "UNSPECIFIED PSYCHOSIS")

```


Figure out all the codes now
These are the codes for unspecified and SCHIZOPHRENIA
SCHIZOPHRENIA, UNSPECIFIED
SCHIZOAFFECTIVE DISORDER, UNSPECIFIED
OTHER SCHIZOAFFECTIVE DISORDERS
UNDIFFERENTIATED SCHIZOPHRENIA
OTHER SCHIZOPHRENIA
OTHER PSYCHOTIC DISORDER NOT DUE TO A SUBSTANCE OR KNOWN PHYSIOLOGICAL CONDITION
UNSPECIFIED SCHIZOPHRENIA SPECTRUM AND OTHER PSYCHOTIC DISORDER
OTHER SPECIFIED SCHIZOPHRENIA SPECTRUM AND OTHER PSYCHOTIC DISORDER
SCHIZOPHRENIA  DISORGANIZED TYPE UNSPECIFIED

Create a unspecified schiz variable
```{r}
library(prettyR)
schiz_data$unspec_var = ifelse(schiz_data$diagnosis == "SCHIZOPHRENIA, UNSPECIFIED" | schiz_data$diagnosis== "SCHIZOAFFECTIVE DISORDER, UNSPECIFIED" | schiz_data$diagnosis == "OTHER SCHIZOAFFECTIVE DISORDERS" | schiz_data$diagnosis == "UNDIFFERENTIATED SCHIZOPHRENIA" | schiz_data$diagnosis == "OTHER SCHIZOPHRENIA" | schiz_data$diagnosis == "OTHER PSYCHOTIC DISORDER NOT DUE TO A SUBSTANCE OR KNOWN PHYSIOLOGICAL CONDITION" | schiz_data$diagnosis == "UNSPECIFIED SCHIZOPHRENIA SPECTRUM AND OTHER PSYCHOTIC DISORDER" | schiz_data$diagnosis == "OTHER SPECIFIED SCHIZOPHRENIA SPECTRUM AND OTHER PSYCHOTIC DISORDER" | schiz_data$diagnosis == "SCHIZOPHRENIA  DISORGANIZED TYPE UNSPECIFIED", 1, 0) 
test = subset(schiz_data, diagnosis == "SCHIZOPHRENIA, UNSPECIFIED")
sum(test$unspec_var) == dim(test)[1]
```

Need one record by client with the "primary diagnosis" or first instance OR the diagnosis that trumps “unspecified”
For duplicates identified those with the first ID as unspecified
Assuming duplicate diagnoses are repeats 
Order by ID and then ranking so if you take the first ID you getting the primary if they are duplicates

```{r}
library(dplyr)
schiz_data$dup_var =  duplicated(schiz_data$client_id)
schiz_data
# sort by id
schiz_data =  schiz_data[order( schiz_data$client_id),]
# Shows that code below works
#vec <- c("a", "b", "c","c","c")
#vec =  vec %in% unique(vec[ duplicated(vec)]) 
#vec
schiz_data$dup_var_all = schiz_data$client_id %in% unique( schiz_data$client_id[duplicated( schiz_data$client_id)])
schiz_data$first_dup = ifelse( schiz_data$dup_var == FALSE &  schiz_data$dup_var_all == TRUE, 1, 0)
### Order by ID and then ranking
schiz_data = schiz_data[order(schiz_data$client_id, schiz_data$diagnosis_ranking),]
schiz_data
```
First person has the same client ID, same service date, different diagnosis, 
```{r}
test = schiz_data
### Keep highest level of diagnosis that is not unspecified
#test  = test[c("client_id", "county", "service_date", "dup_var", "dup_var_all", "diagnosis", "diagnosis_ranking")]
test = test[order(test$client_id, test$service_date),]
test

#test = subset(test, dup_var_all == TRUE)
test_dup = test %>% distinct(client_id, .keep_all = TRUE)
test_dup$service_date = floor_date( test_dup$service_date, unit = c("month"))
n_test = dim(test)[1]
count_month =  test_dup %>% count(service_date)
count_month$percentage_pop = round(count_month$n / n_test,2)*100
count_month$schz = NULL
count_month
#n = dim( schiz_data)[1]
#schiz_data =  schiz_data[,1:9]
#schiz_data$schz = rep(1, dim( schiz_data)[1])

```



1. Get non-first duplicate id and unspecified
2. Drop those who have non-first duplicate id and unspecified
3. Overwrite all duplicate variables and update based on the dropping above 
4. Get first duplicate id and unspecified
5. Drop those who have first duplicate id and unspecified (will only drop duplicates based on previous dropping)
6. Identify those who have more than one ID in the same month.  We want clients per month assuming 
6. Drop remaining duplicates leaving you with highest diagnosis level that is not unspecified
```{r}
schiz_data$non_first_dup_and_unspec = ifelse(schiz_data$dup_var == TRUE &  schiz_data$unspec_var == 1, 1, 0)
schiz_data = subset(schiz_data, non_first_dup_and_unspec == 0)

### Do this in case some clients has two duplicates and we removed their second duplicate above meaning that client is no longer a duplicate
schiz_data$dup_var = duplicated(schiz_data$client_id)
schiz_data$dup_var_all =   schiz_data$client_id %in% unique( schiz_data$client_id[duplicated( schiz_data$client_id)])
schiz_data$first_dup = ifelse( schiz_data$dup_var == FALSE &  schiz_data$dup_var_all == TRUE, 1, 0)
schiz_data


schiz_data$first_dup_unspec = ifelse(schiz_data$first_dup == TRUE &  schiz_data$unspec_var==1, 1, 0)
### EVen though no instances just drop in case you load in data later with repeats
schiz_data = subset( schiz_data, first_dup_unspec == 0)
### Redo duplication because it changed
schiz_data$dup_var = duplicated(schiz_data$client_id)
### Keep highest level of diagnosis that is not unspecified
schiz_data = schiz_data %>% distinct(client_id, .keep_all = TRUE)
n = dim( schiz_data)[1]
schiz_data =  schiz_data[,1:9]
schiz_data$schz = rep(1, dim( schiz_data)[1])
schiz_data$service_date = floor_date( schiz_data$service_date, unit = c("month"))
```
Check unique values
```{r}
schiz_data
```


Table by diagnosis
```{r}
schiz_data
count_diag =  schiz_data %>% count(diagnosis) 
count_diag = count_diag[order(count_diag$n, decreasing = TRUE),]
count_diag$percentage_pop = round(count_diag$n / n,2)*100
count_diag
```


Table by month for all diagnoses
Need to get the number of clients served per year, but even with that this is a very large spike

```{r}
count_month =  schiz_data %>% count(service_date)
count_month$percentage_pop = round(count_month$n / n,2)*100
count_month$schz = NULL
count_month
```
Table by county by four month period
We want the count by four month period (May 2019 to Aug 2019) and compare to same period 2020 by county and state
Start with county then get state
```{r}
n = dim( schiz_data)[1]
# Create the two four month indicators May_2019_Aug_2019 and May_2020_Aug_2020
 schiz_data$month_indicator = ifelse( schiz_data$service_date >= "2019-05-01" &  schiz_data$service_date <= "2019-08-01", "May_2019_Aug_2019", ifelse( schiz_data$service_date >= "2020-05-01" &  schiz_data$service_date <= "2020-08-01",  "May_2020_Aug_2020", "Wrong"))
count_county = subset( schiz_data,month_indicator != "Wrong")
library(tidyverse)
## Need this plus .drop = FALSE to include counting zeros
count_county <- count_county %>% modify_if(is.character, as.factor)
count_county
count_county = count_county %>% group_by(county, month_indicator) %>%  count(schz, .drop = FALSE)
count_county
May_2019_Aug_2019 = subset(count_county, month_indicator == "May_2019_Aug_2019")
May_2020_Aug_2020 = subset(count_county, month_indicator == "May_2020_Aug_2020") 
count_county = data.frame(county = May_2019_Aug_2019$county, May_2019_Aug_2019 = May_2019_Aug_2019$n , May_2020_Aug_2020 = May_2020_Aug_2020$n)
count_county
```
Monthly count of all diagnosis by county
```{r}
month_by_diag_fun = function(data){

data$month_indicator = ifelse(data$service_date >= "2019-05-01" & data$service_date <= "2019-08-01", "May_2019_Aug_2019", ifelse(data$service_date >= "2020-05-01" & data$service_date <= "2020-08-01",  "May_2020_Aug_2020", "Wrong"))
count_county = subset(data,month_indicator != "Wrong")
count_county$month_indicator = NULL
count_county <- count_county %>% modify_if(is.character, as.factor)
count_county = count_county %>% group_by(service_date, county) %>%  count(schz, .drop = FALSE)
count_county$schz = NULL
# Add back later "2019-05-01", "2019-06-01",
month_list = list("2019-07-01", "2019-08-01", "2020-05-01", "2020-06-01", "2020-07-01", "2020-08-01")
out_list = list() 
county = list()
for(i in 1:length(month_list)){
  out_list[[i]] = subset(count_county, service_date == month_list[[i]])
  out_list[[i]]$service_date = NULL
  county[[i]] =  out_list[[1]]$county
  out_list[[i]]$county = NULL
}
out_list = data.frame(out_list)
names(out_list) = c("Jul 2019", "Aug 2019", "May 2020", "June 2020", "July 2020", "Aug 2020")
county = data.frame(county = county)
names(county) = "county"
out_list = cbind(county = county, out_list)
return(out_list)
}
month_by_diag_fun(schiz_data)
```
Function above replicates
```{r}
 schiz_data$month_indicator = ifelse( schiz_data$service_date >= "2019-05-01" &  schiz_data$service_date <= "2019-08-01", "May_2019_Aug_2019", ifelse( schiz_data$service_date >= "2020-05-01" &  schiz_data$service_date <= "2020-08-01",  "May_2020_Aug_2020", "Wrong"))
count_county = subset( schiz_data,month_indicator != "Wrong")
count_county$month_indicator = NULL
count_county <- count_county %>% modify_if(is.character, as.factor)
count_county = count_county %>% group_by(service_date, county) %>%  count(schz, .drop = FALSE)
count_county$schz = NULL
# Add back later "2019-05-01", "2019-06-01",
month_list = list("2019-07-01", "2019-08-01", "2020-05-01", "2020-06-01", "2020-07-01", "2020-08-01")
out_list = list() 
county = list()
for(i in 1:length(month_list)){
  out_list[[i]] = subset(count_county, service_date == month_list[[i]])
  out_list[[i]]$service_date = NULL
  county[[i]] =  out_list[[1]]$county
  out_list[[i]]$county = NULL
}
out_list = data.frame(out_list)
names(out_list) = c("Jul 2019", "Aug 2019", "May 2020", "June 2020", "July 2020", "Aug 2020")
county = data.frame(county = county)
names(county) = "county"
out_list = cbind(county = county, out_list)
out_list

```

Now just SCHIZOAFFECTIVE 
```{r}
dat_SCHIZOAFFECTIVE =  schiz_data
dat_SCHIZOAFFECTIVE$SCHIZOAFFECTIVE =  grepl("SCHIZOAFFECTIVE", dat_SCHIZOAFFECTIVE$diagnosis)
dat_SCHIZOAFFECTIVE = subset(dat_SCHIZOAFFECTIVE, SCHIZOAFFECTIVE == TRUE)
dat_SCHIZOAFFECTIVE
month_by_diag_fun(dat_SCHIZOAFFECTIVE)
```
Now just SCHIZOPHRENIA 
```{r}
dat_SCHIZOPHRENIA  =  schiz_data
dat_SCHIZOPHRENIA$SCHIZOPHRENIA =  grepl("SCHIZOPHRENIA", dat_SCHIZOPHRENIA$diagnosis)
dat_SCHIZOPHRENIA = subset(dat_SCHIZOPHRENIA, SCHIZOPHRENIA == TRUE)
month_by_diag_fun(dat_SCHIZOPHRENIA)
```
Now get all others
```{r}
dat_other  =  schiz_data
dat_other$SCHIZOPHRENIA =  grepl("SCHIZOPHRENIA", dat_other$diagnosis)
dat_other$SCHIZOAFFECTIVE =  grepl("SCHIZOAFFECTIVE", dat_other$diagnosis)
dat_other = subset(dat_other, SCHIZOPHRENIA == FALSE & SCHIZOAFFECTIVE == FALSE)
dat_other
month_by_diag_fun(dat_other)

```

